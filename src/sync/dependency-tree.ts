import { trace } from "@opentelemetry/api";
import { log } from "../log.ts";
import { withSpan } from "../otel.ts";

export type Dependency =
  // a source table with dependencies
  | {
      sourceTable: string;
      sourceSchema: string;
      sourceColumn: string[];
      referencedSchema: string;
      referencedTable: string;
      referencedColumn: string[];
    }
  // a source table with no dependencies
  | {
      sourceTable: string;
      sourceSchema: string;
      sourceColumn: null;
      referencedSchema: null;
      referencedTable: null;
      referencedColumn: null;
    };

/** A pointer from a current table context to another */
interface Pointer {
  sourceSchema: string;
  sourceColumn: string[];
  referencedSchema: string;
  referencedTable: string;
  referencedColumn: string[];
}

declare const hashSymbol: unique symbol;
// TODO: don't export this symbol? But we need the connector to be
// able to construct a valid type for the hash
export type Hash = string & { [hashSymbol]: true };

export type Cursor<T> = AsyncGenerator<T, void, unknown>;

export type InsertableTuple = {
  table: string;
  data: NonNullable<Record<string, unknown>>;
  // hash: Hash;
};

/**
 * A message about the dependency analyzer's process that should be
 * returned to the user. These aren't show-stopping errors but things
 * an end-user should be aware of.
 */
export type DependencyResolutionNotice =
  | { kind: "incomplete_dependency_chain"; chain: string[]; table: string }
  | { kind: "too_few_rows"; table: string; requested: number; found: number };

export type TableRows<
  T extends Record<string, unknown> = Record<string, unknown>
> = Record<TableName, T[]>;

export type FindAllDependenciesError =
  | {
      kind: "error";
      type: "unexpected_error";
      error: Error;
    }
  | {
      kind: "error";
      type: "max_table_iterations_reached";
    };

export type FindAllDependenciesResult<
  T extends Record<string, unknown> = Record<string, unknown>
> =
  | {
      kind: "ok";
      items: TableRows<T>;
      notices: DependencyResolutionNotice[];
    }
  | FindAllDependenciesError;

export type CursorOptions = { requiredRows: number; seed: number };

export interface DatabaseConnector<
  T extends InsertableTuple = InsertableTuple
> {
  cursor(schema: string, table: string, options: CursorOptions): Cursor<T>;
  dependencies(schema: string): Promise<Dependency[]>;
  get(
    schema: string,
    table: string,
    values: Record<string, unknown>
  ): Promise<T | undefined>;
  /** The unique value of the returned tuple */
  hash(value: T): Hash;
  /** Used to run stuff like `vacuum analyze` before the analysis begins */
  onStartAnalyze?(schema: string): Promise<void>;
}

export type DependencyAnalyzerOptions = {
  /**
   * The minimum number of rows to grab for each table.
   */
  requiredRows: number;
  /**
   * The maximum number of rows to allow for a single table.
   *
   * Because of the way dependency resolution works, it's possible to
   * follow a chain of FKs that include many rows from multiple tables
   * that exceed `requiredRows`. This option allows the analyzer to
   */
  maxRows: number;
  /**
   * Random seed for ensuring consistent random sampling.
   * @default 0
   */
  seed: number;
};

/**
 * The dependency analyzer is responsible for finding all dependencies for all tables in a database.
 *
 * One of the problems with restoring a sample of a database is that rows in tables tend to have
 * foreign keys that point to specific rows in other tables. So we can't just pick a bunch of rows
 * at complete random otherwise we'd end up with an inconsistent database.
 *
 * `DependencyAnalyzer` fixes this problem by taking a generic database connector, building a graph of
 * dependencies and traversing all the depedencies that are found in rows generated by the cursor
 * opened by the connector.
 */
export class DependencyAnalyzer<T extends InsertableTuple = InsertableTuple> {
  private readonly seen = new Set<Hash>();
  private static readonly MAX_TABLE_ITERATIONS = 100;
  constructor(
    private readonly connector: DatabaseConnector<T>,
    private readonly options: DependencyAnalyzerOptions
  ) {}

  async findAllDependencies(
    schema: string,
    graph: DependencyGraph
  ): Promise<FindAllDependenciesResult<T["data"]>> {
    log.debug("Starting dependency resolution", "dependency-resolution");
    this.seen.clear();
    try {
      await this.connector.onStartAnalyze?.(schema);

      const items: TableRows<T["data"]> = {};

      // open cursor on all available tables to have a greater chance at an even distribution
      const cursors: Record<TableName, Cursor<T>> = {};
      const remainingTables = Array.from(graph.keys());

      for (const source of remainingTables) {
        cursors[source] = this.connector.cursor(schema, source, this.options);
        items[source] = [];
      }

      let stack: string[] = [];
      const removeTable = (i: number) => {
        if (remainingTables[i] === undefined) {
          log.error(
            `Attempted to remove table ${remainingTables[i]} but it was not found`,
            "dependency-resolution"
          );
          return;
        }
        const cursor = cursors[remainingTables[i]];
        // close the iterator to avoid leaking resources
        cursor?.return();
        delete cursors[remainingTables[i]];
        remainingTables.splice(i, 1);
      };
      const notices: DependencyResolutionNotice[] = [];
      // we want to loop over everything until we've satisfied all table requirements
      for (let i = 0; remainingTables.length > 0; i++) {
        // it's bad to have while(true) loops so this is a just in case
        if (i > DependencyAnalyzer.MAX_TABLE_ITERATIONS) {
          return {
            kind: "error",
            type: "max_table_iterations_reached",
          };
        }
        for (let i = remainingTables.length - 1; i >= 0; i--) {
          const table = remainingTables[i]!;
          const tableItems = items[table];
          if (tableItems === undefined) {
            log.error(
              `Attempted to access table ${table} but it was not found in the items map`,
              "dependency-resolution"
            );
            continue;
          }
          const rowCountSatisfied =
            tableItems.length >= this.options.requiredRows;

          if (rowCountSatisfied) {
            removeTable(i);
            break;
          }

          const cursor = cursors[table];
          if (!cursor) {
            throw new Error(`Cursor for ${table} not found`);
          }
          const span = trace.getActiveSpan();
          const iterator = await cursor.next();
          span?.addEvent("cursor.next");

          if (iterator.done) {
            log.debug(
              `Notice: Table \`${table}\` has fewer rows (${tableItems.length}) than the required (${this.options.requiredRows})`,
              "dependency-resolution"
            );
            notices.push({
              kind: "too_few_rows",
              table,
              requested: this.options.requiredRows,
              found: tableItems.length,
            });
            removeTable(i);
            continue;
          }
          const sourceValue = iterator.value;

          stack = [];
          const results = await this.traverseDependencyChain(
            graph,
            table,
            sourceValue
          );
          for (const result of results) {
            const tableItems = items[result.table];
            if (tableItems === undefined) {
              log.error(
                `Attempted to access table ${result.table} but it was not found in the items map`,
                "dependency-resolution"
              );
              continue;
            }
            stack.push(result.table);
            const chainExceedsMaxRows =
              tableItems.length >= this.options.maxRows;
            // WARNING: BREAKING OUT OF THIS LOOP WILL RESULT IN AN INCONSISTENT DEPENDENCY STATE
            // The only reason this isn't an error is because it's _technically_ possible to restore
            // a database with internally inconsistent foreign key constraints.
            if (chainExceedsMaxRows) {
              log.warn(
                `Notice: Table \`${table}\` has more rows than the maximum ${this.options.maxRows}`,
                "dependency-resolution"
              );
              notices.push({
                kind: "incomplete_dependency_chain",
                chain: stack,
                table,
              });
              break;
            }
            tableItems.push(result.data);
          }
          const hashed = this.connector.hash(sourceValue);
          if (!this.seen.has(hashed)) {
            const tableItems = items[table];
            if (tableItems === undefined) {
              log.error(
                `Attempted to access table ${table} but it was not found in the items map`,
                "dependency-resolution"
              );
              continue;
            }
            tableItems.push(sourceValue.data);
            this.seen.add(hashed);
          }
        }
      }
      log.info(
        `Found ${Object.keys(items).length} tables with ${Object.values(
          items
        ).reduce((acc, table) => acc + table.length, 0)} rows`,
        "dependency-resolution"
      );
      return { kind: "ok", items, notices };
    } catch (error) {
      if (error instanceof Error) {
        log.error(error.message, "dependency-resolution");
        return { kind: "error", type: "unexpected_error", error };
      }
      return {
        kind: "error",
        type: "unexpected_error",
        error: new Error(String(error)),
      };
    }
  }

  /**
   * Generates a chain of all dependencies for a given source node.
   */
  async traverseDependencyChain(
    graph: DependencyGraph,
    source: string,
    value: T
  ): Promise<T[]> {
    const table = graph.get(source);
    if (!table) {
      throw new Error(
        `Table not declared in dependency graph. The graph should include a key for all existing tables in a database, even if they have no dependencies`
      );
    }
    function valuesFor(
      pointer: Pointer
    ):
      | { ok: false; column: string[] }
      | { ok: true; params: Record<string, unknown> } {
      const params: Record<string, unknown> = {};
      // source and referenced columns match by index
      for (let i = 0; i < pointer.sourceColumn.length; i++) {
        const source = pointer.sourceColumn[i]!;
        const reference = pointer.referencedColumn[i]!;
        // if any column of a foreign key is null, we don't follow the dependency
        if (
          value.data == null ||
          !(source in value.data) ||
          value.data[source] == null
        ) {
          return { ok: false, column: pointer.sourceColumn };
        }
        params[reference] = value.data[source];
      }
      return { ok: true, params };
    }

    const results: T[] = [];
    for (const dep of table) {
      const values = valuesFor(dep);
      const fullyReferencesOtherRow = values.ok;
      if (!fullyReferencesOtherRow) {
        continue;
      }
      const referenced = await this.connector.get(
        dep.referencedSchema,
        dep.referencedTable,
        values.params
      );
      if (!referenced) {
        throw new Error(
          `Found an existing FK requirement but there was no corresponding row in ${dep.referencedTable}. Is the database in a consistent state?`
        );
      }
      const hashed = this.connector.hash(referenced);
      if (this.seen.has(hashed)) {
        continue;
      }
      this.seen.add(hashed);
      results.push(referenced);
      const next = await this.traverseDependencyChain(
        graph,
        dep.referencedTable,
        referenced
      );
      results.push(...next);
    }
    return results;
  }

  buildGraph(dependencies: Dependency[]): Promise<DependencyGraph> {
    return withSpan("buildGraph", () => {
      const graph = new Map<TableName, Pointer[]>();
      for (const dependency of dependencies) {
        const existing = graph.get(dependency.sourceTable) ?? [];
        if (dependency.sourceColumn) {
          existing.push({
            sourceSchema: dependency.sourceSchema,
            sourceColumn: dependency.sourceColumn,
            referencedSchema: dependency.referencedSchema,
            referencedTable: dependency.referencedTable,
            referencedColumn: dependency.referencedColumn,
          });
        }
        graph.set(dependency.sourceTable, existing);
      }
      return graph;
    })();
  }
}

type TableName = string;

type DependencyGraph = Map<TableName, Pointer[]>;
